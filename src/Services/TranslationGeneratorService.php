<?php

declare(strict_types=1);

namespace Syriable\Localizator\Services;

use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\File;
use Syriable\Localizator\Contracts\TranslationGenerator;

class TranslationGeneratorService implements TranslationGenerator
{
    private string $langPath;

    private string $localizationType;

    private bool $shouldSort;

    private bool $generateComments;

    private bool $createBackups;

    private int $indent;

    private bool $useNestedStructure;

    public function __construct()
    {
        $this->langPath = resource_path('lang');
        $this->localizationType = Config::get('localizator.localize', 'default');
        $this->shouldSort = Config::get('localizator.sort', true);
        $this->generateComments = Config::get('localizator.output.comments', true);
        $this->createBackups = Config::get('localizator.output.backup', true);
        $this->indent = Config::get('localizator.output.indent', 4);
        $this->useNestedStructure = Config::get('localizator.nested', true);
    }

    public function generateTranslationFiles(array $translationKeys, array $locales): bool
    {
        $success = true;

        foreach ($locales as $locale) {
            $existingTranslations = $this->loadExistingTranslations($locale);
            $newTranslations = $this->prepareTranslations($translationKeys, $existingTranslations);

            if ($this->localizationType === 'json') {
                $success = $success && $this->generateJsonTranslationFile($locale, $newTranslations);
            } else {
                $success = $success && $this->generatePhpTranslationFile($locale, $newTranslations);
            }
        }

        return $success;
    }

    public function generateJsonTranslationFile(string $locale, array $translations): bool
    {
        $filePath = $this->langPath."/{$locale}.json";

        if ($this->createBackups && File::exists($filePath)) {
            $this->createBackup($filePath);
        }

        if ($this->shouldSort) {
            ksort($translations);
        }

        $content = json_encode(
            $translations,
            JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES
        );

        if ($content === false) {
            return false;
        }

        if ($this->generateComments) {
            $comment = "/**\n * Translation file for locale: {$locale}\n * Generated by Syriable Localizator\n * Do not edit this file manually\n */\n";
            $content = $comment.$content;
        }

        $result = File::put($filePath, $content);

        return $result !== false;
    }

    public function generatePhpTranslationFile(string $locale, array $translations): bool
    {
        $success = true;
        $localeDir = $this->langPath."/{$locale}";

        if (! File::exists($localeDir)) {
            File::makeDirectory($localeDir, 0755, true);
        }

        $groupedTranslations = $this->groupTranslationsByFile($translations);

        foreach ($groupedTranslations as $file => $fileTranslations) {
            $filePath = $localeDir."/{$file}.php";

            if ($this->createBackups && File::exists($filePath)) {
                $this->createBackup($filePath);
            }

            $success = $success && $this->writePhpTranslationFile($filePath, $fileTranslations, $locale, $file);
        }

        return $success;
    }

    public function mergeExistingTranslations(string $locale, array $newTranslations): array
    {
        $existingTranslations = $this->loadExistingTranslations($locale);

        // Merge new translations with existing ones, keeping existing values
        foreach ($newTranslations as $key => $value) {
            if (! isset($existingTranslations[$key])) {
                $existingTranslations[$key] = $value;
            }
        }

        // Remove missing translations if configured
        if (Config::get('localizator.remove_missing', false)) {
            $existingTranslations = array_intersect_key($existingTranslations, $newTranslations);
        }

        return $existingTranslations;
    }

    private function loadExistingTranslations(string $locale): array
    {
        $translations = [];

        if ($this->localizationType === 'json') {
            $filePath = $this->langPath."/{$locale}.json";
            if (File::exists($filePath)) {
                $content = File::get($filePath);
                $decoded = json_decode($content, true);
                if (is_array($decoded)) {
                    $translations = $decoded;
                }
            }
        } else {
            $localeDir = $this->langPath."/{$locale}";
            if (File::exists($localeDir)) {
                $files = File::files($localeDir);
                foreach ($files as $file) {
                    if ($file->getExtension() === 'php') {
                        $fileName = $file->getFilenameWithoutExtension();
                        $fileTranslations = include $file->getRealPath();
                        if (is_array($fileTranslations)) {
                            if ($this->useNestedStructure) {
                                $this->flattenNestedTranslations($translations, $fileTranslations, $fileName);
                            } else {
                                foreach ($fileTranslations as $key => $value) {
                                    $translations["{$fileName}.{$key}"] = $value;
                                }
                            }
                        }
                    }
                }
            }
        }

        return $translations;
    }

    private function prepareTranslations(array $translationKeys, array $existingTranslations): array
    {
        $translations = [];

        foreach ($translationKeys as $key) {
            if (isset($existingTranslations[$key])) {
                $translations[$key] = $existingTranslations[$key];
            } else {
                // Use the key as the default value if no translation exists
                $translations[$key] = $key;
            }
        }

        return $translations;
    }

    private function groupTranslationsByFile(array $translations): array
    {
        if (! $this->useNestedStructure) {
            // Legacy flat structure
            return $this->groupTranslationsByFileFlat($translations);
        }

        $grouped = [];

        foreach ($translations as $key => $value) {
            if (str_contains($key, '.')) {
                $keyParts = explode('.', $key);
                $file = array_shift($keyParts); // First part becomes the filename

                // Initialize file array if it doesn't exist
                if (! isset($grouped[$file])) {
                    $grouped[$file] = [];
                }

                // Create nested structure for remaining parts
                $this->setNestedValue($grouped[$file], $keyParts, $value);
            } else {
                // Keys without dots go to 'messages' file
                $file = 'messages';
                if (! isset($grouped[$file])) {
                    $grouped[$file] = [];
                }
                $grouped[$file][$key] = $value;
            }
        }

        return $grouped;
    }

    private function groupTranslationsByFileFlat(array $translations): array
    {
        $grouped = [];

        foreach ($translations as $key => $value) {
            if (str_contains($key, '.')) {
                [$file, $translationKey] = explode('.', $key, 2);
            } else {
                $file = 'messages';
                $translationKey = $key;
            }

            $grouped[$file][$translationKey] = $value;
        }

        return $grouped;
    }

    private function setNestedValue(array &$array, array $keys, string $value): void
    {
        $current = &$array;

        foreach ($keys as $key) {
            if (! isset($current[$key])) {
                $current[$key] = [];
            }
            $current = &$current[$key];
        }

        // Set the final value
        $current = $value;
    }

    private function flattenNestedTranslations(array &$result, array $translations, string $prefix, string $separator = '.'): void
    {
        foreach ($translations as $key => $value) {
            $newKey = $prefix ? "{$prefix}{$separator}{$key}" : $key;

            if (is_array($value)) {
                $this->flattenNestedTranslations($result, $value, $newKey, $separator);
            } else {
                $result[$newKey] = $value;
            }
        }
    }

    private function writePhpTranslationFile(string $filePath, array $translations, string $locale, string $file): bool
    {
        if ($this->shouldSort) {
            ksort($translations);
        }

        $content = "<?php\n\n";

        if ($this->generateComments) {
            $content .= "/**\n";
            $content .= " * Translation file: {$file}\n";
            $content .= " * Locale: {$locale}\n";
            $content .= " * Generated by Syriable Localizator\n";
            $content .= " */\n\n";
        }

        $content .= "return [\n";
        $content .= $this->arrayToString($translations, 1);
        $content .= "];\n";

        $result = File::put($filePath, $content);

        return $result !== false;
    }

    private function arrayToString(array $array, int $level): string
    {
        $content = '';
        $indentStr = str_repeat(' ', $this->indent * $level);

        foreach ($array as $key => $value) {
            $escapedKey = addslashes($key);

            if (is_array($value)) {
                $content .= "{$indentStr}'{$escapedKey}' => [\n";
                $content .= $this->arrayToString($value, $level + 1);
                $content .= "{$indentStr}],\n";
            } else {
                $escapedValue = addslashes($value);
                $content .= "{$indentStr}'{$escapedKey}' => '{$escapedValue}',\n";
            }
        }

        return $content;
    }

    private function createBackup(string $filePath): void
    {
        $timestamp = date('Y-m-d_H-i-s');
        $backupPath = $filePath.".backup_{$timestamp}";
        File::copy($filePath, $backupPath);
    }
}
